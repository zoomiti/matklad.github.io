
<!DOCTYPE html>
<html lang='en-US'>

<head>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Caches In Rust</title>
  <meta name="description" content="In this post I’ll describe how to implement caches in Rust.
It is inspired by two recent refactors I landed at nearcore (&lt;a href="https://github.com/near/nearcore/pull/6549"&gt;nearcore#6549&lt;/a&gt;, &lt;a href="https://github.com/near/nearcore/pull/6811"&gt;nearcore#6811&lt;/a&gt;).
Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks “spilling over”, and spoiling the overall architecture of the application a bit.">
  <link rel="canonical" href="https://matklad.github.io/2022/06/11/caches-in-rust.html">
  <link rel="alternate" type="application/rss+xml" title="matklad" href="https://matklad.github.io/feed.xml">
  <style>
  @font-face {
    font-family: 'JetBrains Mono';
    src: url('/css/JetBrainsMono-Regular.woff2') format('woff2');
  }

  @font-face {
    font-family: 'JetBrains Mono';
    src: url('/css/JetBrainsMono-Bold.woff2') format('woff2');
    font-weight: bold;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; margin-block-start: 0; margin-block-end: 0; }

  h1, h2, h3 { font-weight: 300; }

  body { display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
  main { display: flex; flex-direction: column; width: 100%; max-width: 80ch; padding-left: 2ch; padding-right: 2ch; }

  header { width: 100%; max-width: 80ch; margin-bottom: 1.5rem; }
  header > nav { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: baseline; }
  header a { font-style: normal; margin-left: 1ch; margin-right: 1ch; line-height: 1.5rem; color: rgba(0, 0, 0, .8); text-decoration: none; }
  header a:hover { color: rgba(0, 0, 0, .8); text-decoration: underline; }
  header .title { font-size: 1.25em; flex-grow: 2; }

  footer { display: flex; justify-content: center; align-items: baseline; width: 100%; max-width: 80ch; margin-top: 1rem; height: 2rem; padding-left: 1ch; padding-right: 1ch; }
  footer > p { margin-bottom: 0; }
  footer a { padding-left: 2ch; font-style: normal; color: rgba(0, 0, 0, .8); text-decoration: none; white-space: nowrap; }
  footer i { vertical-align: middle; color: rgba(0, 0, 0, .8) }

  </style>

  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=EB+Garamond:400,400italic,700,700italic%7COpen+Sans:300">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
</head>

<body>
  <header>
    <nav>
      <a class="title" href="/">matklad</a>
      <a href="/about.html">About</a>
      <a href="/resume.html">Resume</a>
    </nav>
  </header>

  <main>
  <article>

<h1 id="Caches-In-Rust">
<a href="#Caches-In-Rust">Caches In Rust <time datetime="2022-06-11">Jun 11, 2022</time></a>
</h1>

<p>In this post I’ll describe how to implement caches in Rust.
It is inspired by two recent refactors I landed at nearcore (<a href="https://github.com/near/nearcore/pull/6549">nearcore#6549</a>, <a href="https://github.com/near/nearcore/pull/6811">nearcore#6811</a>).
Based on that experience, it seems that implementing caches wrong is rather easy, and making a mistake there risks “spilling over”, and spoiling the overall architecture of the application a bit.</p>

<p>Let’s start with an imaginary setup with an application with some configuration and a database:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>}</code></pre>

</figure>
<p>The database is an untyped key-value store:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">impl</span> <span class="hl-title class_">Db</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">load</span>(&amp;<span class="hl-keyword">self</span>, key: &amp;[<span class="hl-type">u8</span>]) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;<span class="hl-type">Vec</span>&lt;<span class="hl-type">u8</span>&gt;&gt;&gt; {</code>
<code>    ...</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>And the <code>App</code> encapsulates database and provides typed access to domain-specific <code>Widget</code>:</p>

<figure class="code-block">


<pre><code><span class="hl-meta">#[derive(serde::Serialize, serde::Deserialize)]</span></code>
<code><span class="hl-keyword">struct</span> <span class="hl-title class_">Widget</span> {</code>
<code>  title: <span class="hl-type">String</span>,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code>    &amp;<span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code>  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;Widget&gt;&gt; {</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>Now, for the sake of argument let’s assume that database access and subsequent deserialization are costly, and that we want to add a cache of Widgets in front of the database.
Data-oriented thinking would compel us to get rid of deserialization step instead, but we will not pursue that idea this time.</p>

<p>We’ll use a simple <code>HashMap</code> for the cache:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>  cache: HashMap&lt;<span class="hl-type">u32</span>, Widget&gt;,</code>
<code>}</code></pre>

</figure>
<p>And we need to modify <code>get_widget</code> method to return the value from the cache, if there is one:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code class="hl-line">    &amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code class="hl-line">  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;&amp;Widget&gt;&gt; {</code>
<code></code>
<code class="hl-line">    <span class="hl-keyword">if</span> <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">contains_key</span>(&amp;id) {</code>
<code class="hl-line">      <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get</span>(&amp;id).<span class="hl-title function_ invoke__">unwrap</span>();</code>
<code class="hl-line">      <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget));</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code class="hl-line">    <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">insert</span>(id, widget);</code>
<code class="hl-line">    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get</span>(&amp;id).<span class="hl-title function_ invoke__">unwrap</span>();</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>The biggest change is the <code>&amp;mut self</code>.
Even when reading the widget, we need to modify the <code>cache</code>, and the easiest way to get that ability is to require an exclusive reference.</p>

<p>I want to argue that this path of least resistance doesn’t lead to a good place.
There are <em>many</em> problems with methods of the following-shape:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;Widget</code></pre>

</figure>
<p><em>First</em>, such methods conflict with each other.
For example, the following code won’t work, because we’ll try to borrow the app exclusively twice.</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">let</span> <span class="hl-variable">app</span>: &amp;<span class="hl-keyword">mut</span> App = ...;</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">w1</span> = app.<span class="hl-title function_ invoke__">get_widget</span>(<span class="hl-number">1</span>)?;</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">w2</span> = app.<span class="hl-title function_ invoke__">get_widget</span>(<span class="hl-number">2</span>)?;</code></pre>

</figure>
<p><em>Second</em>, the <code>&amp;mut</code> methods conflict even with <code>&amp;</code> methods.
Naively, it would seem that, as <code>get_widget</code> <em>returns</em> a shared reference, we should be able to call <code>&amp;</code> methods.
So, one can expect something like this to work:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">let</span> <span class="hl-variable">w</span>: &amp;Widget = app.<span class="hl-title function_ invoke__">get_widget</span>(<span class="hl-number">1</span>)?.<span class="hl-title function_ invoke__">unwrap</span>();</code>
<code><span class="hl-keyword">let</span> <span class="hl-variable">c</span>: &amp;Color = &amp;app.config.main_color;</code></pre>

</figure>
<p>Alas, it doesn’t.
Rust borrow checker doesn’t distinguish between <code>mut</code> and non-<code>mut</code> lifetimes (for a good reason: doing that would be unsound).
So, although <code>w</code> is just <code>&amp;Widget</code>, the lifetime there is the same as on the <code>&amp;mut self</code>, so the app remains mutably borrowed while the widget exists.</p>

<p><em>Third</em>, perhaps the most important point, the <code>&amp;mut self</code> becomes viral — most of functions in the program begin requiring <code>&amp;mut</code>, and you lose type-system distinction between read-only and read-write operations.
There’s no distinction between “this function can only modify the cache” and “this function can modify literally everything”.</p>

<p><em>Finally</em>, even implementing <code>get_widget</code> is not pleasant.
Seasoned rustaceans among you might twitch at the needlessly-repeated hashmap lookups.
But trying to get rid of those with the help of the entry-API runs into current borrow checker limitations.</p>

<p>Let’s look at how we can better tackle this!</p>

<p>The general idea for this class of problems is to think what the ownership and borrowing situation <em>should</em> be and try to achieve that, as opposed to merely following suggestions by the compiler.
That is, <em>most</em> of the time just using <code>&amp;mut</code> and <code>&amp;</code> as compiler guides you is a path to success, as, it turns out, majority of the code naturally follows simple aliasing rules.
But there are exceptions, it’s important to recognize them as such and make use of interior mutability to implement the aliasing structure which makes sense.</p>

<p>Let’s start with a simplified case.
Suppose that there’s only one <code>Widget</code> to deal with.
In this case, we’d want something like this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  ...</code>
<code>  cache: <span class="hl-type">Option</span>&lt;Widget&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;Widget {</code>
<code>    <span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(widget) = &amp;<span class="hl-keyword">self</span>.cache {</code>
<code>      <span class="hl-keyword">return</span> widget;</code>
<code>    }</code>
<code class="hl-line">    <span class="hl-keyword">self</span>.cache = <span class="hl-title function_ invoke__">Some</span>(<span class="hl-title function_ invoke__">create_widget</span>());</code>
<code>    <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">as_ref</span>().<span class="hl-title function_ invoke__">unwrap</span>()</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>This doesn’t work as is — modifying the <code>cache</code> needs <code>&amp;mut</code> which we’d very much prefer to avoid.
However, thinking about this pattern, it feels like it <em>should</em> be valid — we enforce at runtime that the contents of the <code>cache</code> is never overwritten.
That is, we actually <em>do</em> have exclusive access to cache on the highlighted line at runtime, we just can’t explain that to the type system.
But we can reach out for <code>unsafe</code> for that.
What’s more, Rust’s type system is powerful enough to encapsulate that usage of unsafe into a safe and generally re-usable API.
So let’s pull <a href="https://docs.rs/once_cell"><code>once_cell</code></a> crate for this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  ...</code>
<code>  cache: once_cell::sync::OnceCell&lt;Widget&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;Widget {</code>
<code>    <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get_or_init</span>(create_widget)</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>Coming back to the original hash-map example, we can apply the same logic here:
as long as we never overwrite, delete or move values, we can safely return references to them.
This is handled by the <a href="https://docs.rs/elsa"><code>elsa</code></a> crate:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>  cache: elsa::map::FrozenMap&lt;<span class="hl-type">u32</span>, <span class="hl-type">Box</span>&lt;Widget&gt;&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code>    &amp;<span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code>  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;&amp;Widget&gt;&gt; {</code>
<code>    <span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(widget) = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">get</span>(&amp;id) {</code>
<code>      <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget));</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">insert</span>(id, <span class="hl-type">Box</span>::<span class="hl-title function_ invoke__">new</span>(widget));</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>The third case is that of a bounded cache.
If you need to evict values, than the above reasoning does not apply.
If the user of a cache gets a <code>&amp;T</code>, and than the corresponding entry is evicted, the reference would dangle.
In this situations, we want the clients of the cache to co-own the value.
This is easily handled by an <code>Rc</code>:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">struct</span> <span class="hl-title class_">App</span> {</code>
<code>  config: Config,</code>
<code>  db: Db,</code>
<code>  cache: RefCell&lt;lru::LruCache&lt;<span class="hl-type">u32</span>, Rc&lt;Widget&gt;&gt;&gt;,</code>
<code>}</code>
<code></code>
<code><span class="hl-keyword">impl</span> <span class="hl-title class_">App</span> {</code>
<code>  <span class="hl-keyword">pub</span> <span class="hl-keyword">fn</span> <span class="hl-title function_">get_widget</span>(</code>
<code>    &amp;<span class="hl-keyword">self</span>,</code>
<code>    id: <span class="hl-type">u32</span>,</code>
<code>  ) <span class="hl-punctuation">-&gt;</span> io::<span class="hl-type">Result</span>&lt;<span class="hl-type">Option</span>&lt;Rc&lt;Widget&gt;&gt;&gt; {</code>
<code>    {</code>
<code>      <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">cache</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">borrow_mut</span>();</code>
<code>      <span class="hl-keyword">if</span> <span class="hl-keyword">let</span> <span class="hl-variable">Some</span>(widget) = cache.<span class="hl-title function_ invoke__">get</span>(&amp;id) {</code>
<code>        <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(Rc::<span class="hl-title function_ invoke__">clone</span>(widget)));</code>
<code>      }</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">key</span> = id.<span class="hl-title function_ invoke__">to_be_bytes</span>();</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">value</span> = <span class="hl-keyword">match</span> <span class="hl-keyword">self</span>.db.<span class="hl-title function_ invoke__">load</span>(&amp;key)? {</code>
<code>      <span class="hl-literal">None</span> =&gt; <span class="hl-keyword">return</span> <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-literal">None</span>),</code>
<code>      <span class="hl-title function_ invoke__">Some</span>(it) =&gt; it,</code>
<code>    };</code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span>: Widget =</code>
<code>      bincode::<span class="hl-title function_ invoke__">deserialize</span>(&amp;value).<span class="hl-title function_ invoke__">map_err</span>(|it| {</code>
<code>        io::Error::<span class="hl-title function_ invoke__">new</span>(io::ErrorKind::InvalidData, it)</code>
<code>      })?;</code>
<code></code>
<code>    <span class="hl-keyword">let</span> <span class="hl-variable">widget</span> = Rc::<span class="hl-title function_ invoke__">new</span>(widget);</code>
<code>    {</code>
<code>      <span class="hl-keyword">let</span> <span class="hl-keyword">mut </span><span class="hl-variable">cache</span> = <span class="hl-keyword">self</span>.cache.<span class="hl-title function_ invoke__">borrow_mut</span>();</code>
<code>      cache.<span class="hl-title function_ invoke__">put</span>(id, Rc::<span class="hl-title function_ invoke__">clone</span>(&amp;widget));</code>
<code>    }</code>
<code></code>
<code>    <span class="hl-title function_ invoke__">Ok</span>(<span class="hl-title function_ invoke__">Some</span>(widget))</code>
<code>  }</code>
<code>}</code></pre>

</figure>
<p>To sum up: when implementing a cache, the path of the least resistance is to come up with a signature like this:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">mut</span> <span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;T</code></pre>

</figure>
<p>This often leads to problems down the line.
It’s usually better to employ some interior mutability and get either of these instead:</p>

<figure class="code-block">


<pre><code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> &amp;T</code>
<code><span class="hl-keyword">fn</span> <span class="hl-title function_">get</span>(&amp;<span class="hl-keyword">self</span>) <span class="hl-punctuation">-&gt;</span> T</code></pre>

</figure>
<p>This is an instance of the more general effect: despite the “mutability” terminology, Rust references track not mutability, but aliasing.
Mutability and exclusive access are correlated, but not perfectly.
It’s important to identify instances where you need to employ interior mutability, often they are architecturally interesting.</p>

<p>To learn more about relationships between aliasing and mutability, I recommend the following two posts:</p>

<dl >  <dt>Rust: A unique perspective</dt>
  <dd>
<p><a class="url" href="https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html">https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</a></p>
</dd>
  <dt>Accurate mental model for Rust’s reference types</dt>
  <dd>
<p><a class="url" href="https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html">https://docs.rs/dtolnay/latest/dtolnay/macro._02__reference_types.html</a></p>
</dd>
</dl>

<p>Finally, the “borrow checker” limitation is explained (with much skill and humor, I should add), in this document:</p>

<dl >  <dt>Polonius the Crab</dt>
  <dd>
<p><a class="url" href="https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/">https://docs.rs/polonius-the-crab/0.2.1/polonius_the_crab/</a></p>
</dd>
</dl>

<p>That’s all! Discussion on <a href="https://old.reddit.com/r/rust/comments/v9xsnb/blog_post_caches_in_rust/">/r/rust</a>.</p>
</article>
  </main>

  <footer class="site-footer">
    <p>
      <a href="https://github.com/matklad/matklad.github.io/edit/master/src/posts/2022-06-11-caches-in-rust.djot">
        <i class="fa fa-edit"></i> fix typo
      </a>

      <a href="/feed.xml">
        <i class="fa fa-rss"></i> rss
      </a>

      <a href="https://github.com/matklad">
        <i class="fa fa-github"></i> matklad
      </a>
    </p>
  </footer>
</body>

</html>
